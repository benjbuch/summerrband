% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_binding_isotherm.R
\name{fit_binding_isotherm}
\alias{fit_binding_isotherm}
\title{Fit binding isotherm}
\usage{
fit_binding_isotherm(
  x,
  formula,
  degree = NULL,
  type = "macro",
  INDEX = NULL,
  limits_lower = c(-Inf, +Inf),
  limits_upper = c(-Inf, +Inf),
  limits_K_d = c(0, 1000),
  start_K_d = 10^c(-1, 4),
  correlation = c(ab = 2, ac = 2, bc = 2, abc = 6)
)
}
\arguments{
\item{x}{A data frame to be evaluated.}

\item{formula}{A formula using variables of \code{x}; given as \code{RL ~ L0},
where \code{RL} is the variable that describes the (normalized) concentration
of the complex \eqn{[RL]_0}, and \code{L0} the concentration of titrated species
\eqn{[L]_0}.}

\item{degree}{The order of the binding polynomial; if \code{NULL} it is inferred
from the number of variables on the LHS of \code{formula}. Up to third order
binding polynomials are supported.}

\item{type}{Either \code{"micro"} or \code{"macro"} (default).}

\item{INDEX}{A column variable that shall be used to split the data into at
most two sets, for which both will share higher order K. You will get other
estimates as .x and .y fits.}

\item{limits_lower}{Upper and lower bounds
for the paramters to be fitted.}

\item{limits_upper}{Upper and lower bounds
for the paramters to be fitted.}

\item{limits_K_d}{Upper and lower bounds
for the paramters to be fitted.}

\item{start_K_d}{Upper and lower bounds of the K_d grid-start
parameters (see \link[nls.multstart:nls_multstart]{nls.multstart::nls_multstart}).}

\item{correlation}{The correlation factors between the microscopic binding
constants; must be a named vector with "ab", "bc", "ac", "abc" as names.}
}
\description{
Fit binding isotherm
}
\details{
The \code{formula} LHS should evaluate to the observed binding isotherm, i.e.
the number of ligands bound at the given concentration (RHS). Column arithmetics
are accepted and even preferred as the number of variables in the LHS will be
used to determine the binding degree: \code{bound_1 + 2 * bound_2 ~ conc}
indicates a second degree binding polynom.

If \code{type == "macro"}, the binding isotherm is computed for a macroscopic
(thermodynamic) process using \code{\link{gpf_macro}}.

If \code{type == "micro"},
the intrinsic binding constants of the individual binding sites are computed
temptatively using correlations that yield to harmonic means. (In any system
this is non-sensical.) The vector must be strictly named with "ab", "bc", "ac",
"abc" as appropriate. Missing values will be set to 0, i.e., the result
will be the same as for \code{type == "macro"}.

The grid start approach will take 540 points across all model estimates.

If \code{INDEX} is a column name, the data is internally split into (exactly)
two groups, for which the higher order K are shared. Note that the grid start
approach will take 1296 points and computation may take longer.

Up to third order binding polynoms can be computed.

Note that all K_d values are internally log-transformed and returned as such
to allow for an equal search depth across all orders of magnitude using
\link[nls.multstart:nls_multstart]{nls.multstart::nls_multstart}.
}
\examples{
library(dplyr)
assay_file <- system.file("extdata", "gel_03.txt", package = "summerrband")
assay_data <- iqtl_meta(assay_file, list(conc = c(2^seq(10, 0), 0)))

test3 <- assay_data \%>\%
  group_by(gel_id) \%>\%
  tidyr::pivot_wider(names_from = band_id, values_from = vol_frac,
  id_cols = c(conc, group_vars(.))) \%>\%
  model_cleanly_groupwise(fit_binding_isotherm, formula = band_1 + 2 * band_2 ~ conc,
                          newdata = data.frame(conc = 10^seq(-3, 3, length.out = 100)))

tidyr::unnest(test3, tidy)

library(ggplot2)
model_display(test3) + scale_x_log10()

# fitting with shared estimates
assay_data_2 <- assay_data \%>\%
  group_by(gel_id) \%>\%
  tidyr::pivot_wider(names_from = band_id, values_from = vol_frac,
  id_cols = c(conc, group_vars(.))) \%>\%
  mutate(index_col = rep(c("a", "b"), times = 6))

# these examples will take some computation time ...
#
# fit_binding_isotherm(assay_data_2, formula = band_1 + 2 * band_2 ~ conc, INDEX = index_col)
#
# test4 <- assay_data_2 \%>\%
#   model_cleanly_groupwise(fit_binding_isotherm, formula = band_1 + 2 * band_2 ~ conc,
#                           INDEX = index_col,
#                           newdata = data.frame(conc = 10^seq(-3, 3, length.out = 100)))

}
